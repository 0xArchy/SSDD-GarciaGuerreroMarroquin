#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# pylint: disable=W1203

'''
    ICE Gauntlet Remote Game
'''

import sys
import atexit
import logging
import argparse
import json
import Ice
Ice.loadSlice('Icegauntlet.ice')
import IceGauntlet

import game
import game.common
import game.screens
import game.pyxeltools
import game.orchestration


EXIT_OK = 0
BAD_COMMAND_LINE = 1

DEFAULT_ROOM = 'tutorial.json'
DEFAULT_HERO = game.common.HEROES[0]


class RemoteDungeonMap(Ice.Application):

    def __init__(self,hero):
        self.hero = hero

    def run(self,argv):
        self.proxy = self.communicator().stringToProxy(argv[1])
        self.gameservice = IceGauntlet.GamePrx.checkedCast(self.proxy)
        if not self.gameservice:
            raise RuntimeError('Invalid proxy')
        gauntlet = game.Game(self.hero, self)
        game.pyxeltools.initialize()
        gauntlet.add_state(game.screens.TileScreen, game.common.INITIAL_SCREEN)
        gauntlet.add_state(game.screens.StatsScreen, game.common.STATUS_SCREEN)
        gauntlet.add_state(game.screens.GameScreen, game.common.GAME_SCREEN)
        gauntlet.add_state(game.screens.GameOverScreen, game.common.GAME_OVER_SCREEN)
        gauntlet.add_state(game.screens.GoodEndScreen, game.common.GOOD_END_SCREEN)
        gauntlet.start()

    @property
    def next_room(self):
        try:
            self.mapa = self.gameservice.getRoom()
            return json.dumps(self.mapa)

        except IceGauntlet.RoomNotExists:
            print('Not more rooms')
    @property
    def finnished(self):
        return not self.map

@atexit.register
# pylint: disable=W0613
def bye(*args, **kwargs):
    '''Exit callback, use for shoutdown'''
    print('Thanks for playing!')
# pylint: enable=W0613

def parse_commandline():
    '''Parse and check commandline'''
    parser = argparse.ArgumentParser('IceDungeon Local Game')
    #parser.add_argument('LEVEL', nargs='+', default=[DEFAULT_ROOM], help='List of levels')
    parser.add_argument('PROXY',nargs='+', default=None,help='Proxy GameServer')
    parser.add_argument(
        '-p', '--player', default=DEFAULT_HERO, choices=game.common.HEROES,
        dest='hero', help='Hero to play with'
    )
    options = parser.parse_args()

    #for level_file in options.LEVEL:
    #    if not game.assets.search(level_file):
    #        logging.error(f'Level "{level_file}" not found!')
    #        return None
    return options

def main(argv):
    '''Start game according to commandline'''
    user_options = parse_commandline()
    if not user_options:
        return BAD_COMMAND_LINE
    #dungeon = game.DungeonMap(user_options.LEVEL)
    dungeon = RemoteDungeonMap(argv[1])
    dungeon.main(sys.argv)
    gauntlet = game.Game(user_options.hero, dungeon)
    game.pyxeltools.initialize()

    return EXIT_OK


if __name__ == '__main__':
    sys.exit(main(sys.argv))
